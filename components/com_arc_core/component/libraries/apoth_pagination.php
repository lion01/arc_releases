<?php
/**
 * @package     Arc
 * @subpackage  Core
 * @copyright   Copyright (C) 2005 Punnet. All rights reserved. See COPYRIGHT_ARC.txt
 * @license     http://www.gnu.org/licenses/gpl.html GNU/GPL. See LICENSE_ARC.txt
 * Arc is free software: you can redistribute it and/or modify
 * it under the terms of version 3 of the GNU General Public License
 * as published by the Free Software Foundation.
 * The disclaimer of warranty as stated in the GPL applies to this program
 */

defined( '_JEXEC' ) or die( 'Restricted access' );

/**
 * Apotheosis Pagination
 */
class ApothPagination extends JObject
{
	/**
	 * Array of all the paginatores we have we have instanciated
	 * Keyed on paginator ident
	 *
	 * @var array
	 */
	static $_instances = array();
	
	/**
	 * Static method to retrieve the singleton instance of the pagination class named
	 * 
	 * @param string $ident  The component.factory identifier 
	 * @param object $paginator  Optionally the instance of the named paginator
	 * @param array $requirements  Optional array of requirements to supply to the associated factory
	 * @param array $order  Optional array to order the results and by what criteria
	 * @param int $pagesize  Optional page size
	 * @return object  The pagination object
	 */
	function &_( $ident, &$paginator = null, $requirements = null, $order = null, $pageSize = null )
	{
		$i = &self::$_instances;
		
		// do we have an existing pagination object or do we need to create a new one
		$ident = strtolower( $ident );
		if( !isset($i[$ident]) ) {
			// use provided pagination object if it is of the right type
			if( is_a($paginator, 'ApothPagination') ) {
				$i[$ident] = &$paginator;
			}
			// create new pagination object
			else {
				$i[$ident] = new ApothPagination( $ident );
			}
			
			// get the factory for the pagination object to use
			$identParts = explode( '.', $ident, 3 );
			$factoryIdent = $identParts[0].'.'.$identParts[1];
			$factory = &ApothFactory::_( $factoryIdent );
			
			if( $factory == false ) {
				// mark as invalid
				$i[$ident] = false;
			}
			else {
				$i[$ident]->setFactory( $factory );
				
				// set any starting params
				if( !is_null( $requirements ) ) {
					$i[$ident]->setData( $requirements, $order );
				}
				if( !is_null($pageSize) ) {
					$i[$ident]->setPageSize( $pageSize );
				}
			}
		}
		
		return $i[$ident];
	}
	
	/**
	 * Array of all the incFiles for this paginator
	 * 
	 * @var array
	 */
	var $_incFiles;
	
	/**
	 * The given ident for this paginator
	 *
	 * @var string
	 */
	var $_ident;
	
	/**
	 * The ident of the factory used by this paginator
	 *
	 * @var string
	 */
	var $_factoryIdent;
	
	/**
	 * The factory used by this paginator
	 *
	 * @var object
	 */
	var $_factory;
	
	/**
	 * Page size used by this paginator
	 *
	 * @var int
	 */
	var $_pageSize;
	
	/**
	 * Number of pages each side of the current page to load by this paginator
	 *
	 * @var int
	 */
	var $_rollSize;
	
	/**
	 * Array of all the object IDs for this paginator
	 *
	 * @var array
	 */
	var $_pagedIds;
	
	/**
	 * Number of pages of object IDs currently in this paginator
	 *
	 * @var int
	 */
	var $_pageCount;
	
	/**
	 * The current page number in use by this paginator
	 *
	 * @var int
	 */
	var $_page;
	
	/**
	 * Array of the IDs of instances currently instanciated by the factory
	 *
	 * @var array
	 */
	var $_loadedPages;
	
	/**
	 * Data signature generated by this paginator when querying the factory
	 *
	 * @var string
	 */
	var $_dataSignature;
	
	/**
	 * Paginaton object constructor
	 * 
	 * @param string $ident  The component.factory identifier 
	 */
	function __construct( $ident )
	{
		$this->_ident = $ident;
		$this->_factoryIdent = null;
		$this->_factory = null;
		$this->_pageSize = 10;
		$this->_rollSize = 2;
		$this->_pagedIds = array();
		$this->_pageCount = 0;
		$this->_page = 0;
		$this->_loadedPages = array();
		$this->_dataSignature = null;
		$this->_setPageCount();
	}
	
	/**
	 * Pagination object destructor
	 */
	function __destruct()
	{
		// unregister this consumer from its associated factory
		$this->_factory->unRegConsumer( $this->_dataSignature, $this->_ident );
	}
	
	/**
	 * On sleep we need to minify
	 */
	function __sleep()
	{
		// process vars for persisting
		$sleepVars = array();
		
		// store the factory ident
		if( is_null($this->_factoryIdent) ) {
			$identParts = explode( '.', $this->_ident, 3 );
			$this->_factoryIdent = $identParts[0].'.'.$identParts[1];
		}
		
		// always persist
		$sleepVars[] = '_ident';
		$sleepVars[] = '_factoryIdent';
		$sleepVars[] = '_pageSize';
		$sleepVars[] = '_rollSize';
		$sleepVars[] = '_pagedIds';
		$sleepVars[] = '_pageCount';
		$sleepVars[] = '_page';
		$sleepVars[] = '_loadedPages';
		$sleepVars[] = '_dataSignature';
		
		return $sleepVars;
	}
	
	/**
	 * On wakeup we need to un-minify
	 */
	function __wakeup()
	{
		// restore the factory
		$this->_factory = &ApothFactory::_( $this->_factoryIdent );
	}
	
	/**
	 * Set the factory to use with this pagination object
	 * 
	 * @param object $factory  Factory object
	 */
	function setFactory( &$factory )
	{
		$this->_factory = &$factory;
	}
	
	
	/**
	 * Retrieve the factory for this pagination object
	 * 
	 * @return object  The factory associated with this pagination object
	 */
	function &getFactory()
	{
		return $this->_factory;
	}
	
	/**
	 * Set the requirements and ordering and manage registration with factory class
	 * 
	 * @param array $requirements  Array of requirements to supply to associated factory
	 * @param array $order  Array to order the results and by what criteria
	 */
	function setData( $requirements, $order )
	{
		$regHash = $this->_factory->getRegHash( $requirements, $order );
		if( $this->_dataSignature != $regHash ) {
			if( !is_null($this->_dataSignature) ) {
				$this->_factory->unRegConsumer( $this->_dataSignature, $this->_ident );
			}
			$this->_dataSignature = $regHash;
			$this->_factory->regConsumer( $this->_dataSignature, $this->_ident, self::$_instances[$this->_ident] );
			$this->_trimLoadedData( true );
			$this->_loadedPages = array();
			$this->_pagedIds = $this->_factory->getInstances( $requirements, false, $order );
			$this->_setPageCount();
			$this->_page = 0;
		}
	}
	
	/**
	 * Retrieve the current page size
	 * 
	 * @return int  The number of items per page
	 */
	function getPageSize()
	{
		return $this->_pageSize;
	}
	
	/**
	 * Set the required page size
	 * 
	 * @param int $size  Page size
	 * @param int $rollSize  Number of pages either side of current page to cache
	 */
	function setPageSize( $size, $rollSize = null ) 
	{
		if( !is_null($rollSize) ) {
			$this->_rollSize = $rollSize;
		}
		$this->_trimLoadedData();
		
		$this->_pageSize = (int)$size;
		$this->_setPageCount();
	}
	
	/**
	 * Get the ident for this paginator
	 * 
	 * @return string  The ident for this paginator
	 */
	function getIdent()
	{
		return $this->_ident;
	}
	
	/**
	 * Re-register this paginator consumer class with its factory
	 * Called by ApothModel after this paginator is awoken
	 */
	function regWithFactory()
	{
		$this->_factory->regConsumer( $this->_dataSignature, $this->_ident, self::$_instances[$this->_ident] );
		
	}
	
	/**
	 * Retrieve the current page count
	 * 
	 * @return int  The current number of pages
	 */
	function getPageCount()
	{
		return $this->_pageCount;
	}
	
	/**
	 * Derive and set the number of pages
	 */
	function _setPageCount()
	{
		$this->_pageCount = ceil( count($this->_pagedIds) / $this->_pageSize );
	}
	
	/**
	 * Retrieve the current page number
	 * 
	 * @return int $this->_page  The current page number
	 */
	function getPage()
	{
		return $this->_page;
	}
	
	/**
	 * Set which page to be the current page
	 * 
	 * @param int $pageNum  The desired page number
	 * @return int $this->_page  The page number that was set
	 */
	function setPage( $pageNum )
	{
		if( $pageNum >= $this->_pageCount ) {
			$pageNum = $this->_pageCount - 1;
		}
		elseif( $pageNum < 0 ) {
			$pageNum = 0;
		}
		$this->_page = (int)$pageNum;
		
		return $this->_page;
	}
	
	/**
	 * Retrieve the total number of items in the pagination object
	 * 
	 * @return int  The total number of items
	 */
	function getInstanceCount()
	{
		return count( $this->_pagedIds );
	}
	
	/**
	 * Retrieves the given page worth of instances
	 * 
	 * @param int $pagenum  The page number whose contents we want
	 * @param boolean $init  Do we want to also initialise and cache the objects
	 * @return array $ids  The IDs of the instances on the given page
	 */
	function getPagedInstances( $pageNum = null, $init = true )
	{
		if( $this->_pageCount == 0 ) {
			$ids = array();
		}
		else {
			if( !is_null($pageNum) ) {
				$this->setPage( $pageNum );
			}
			$start = $this->_page * $this->_pageSize;
			$ids = array_slice( $this->_pagedIds, $start, $this->_pageSize );
			
			if( $init ) {
				$this->_factory->getInstances( array('id'=>$ids), $init );
			}
			
			if( array_search($this->_page, $this->_loadedPages) === false ) {
				$this->_loadedPages[] = $this->_page;
				$this->_trimLoadedData();
			}
		} 
		
		return $ids;
	}
	
	/**
	 * Retrieves all the instances in the pagination object
	 * 
	 * @param boolean $init  Do we want to also initialise and cache the objects
	 * @return array $ids  The IDs of all the instances
	 */
	function getAllInstances( $init = true )
	{
		$ids = $this->_loadedPages = $this->_pagedIds;
		
		if( $init ) {
			$this->_factory->getInstances( array('id'=>$ids), $init );
		}
		
		return $ids;
	}
	
	/**
	 * Trim the number of loaded pages, and therefore contained objects,
	 * to current and rollsize in each direction
	 * 
	 * @param boolean $all  Optionally do we want to just free up all pages and associated objects
	 */
	function _trimLoadedData( $all = false )
	{
		// make sure loaded pages are in the right order
		asort( $this->_loadedPages );
		
		foreach( $this->_loadedPages as $k=>$page ) {
			if( $all
			 || (($page + $this->_rollSize) < $this->_page)
			 || (($page - $this->_rollSize) > $this->_page) ) {
				// free all the instances for that page
				$start = $page * $this->_pageSize;
				$ids = array_slice( $this->_pagedIds, $start, $this->_pageSize );
				foreach( $ids as $id ) {
					$this->_factory->freeInstance( $id );
				}
				unset( $this->_loadedPages[$k] );
			}
		}
	}
	
	/**
	 * Completely reset the pagination object
	 * 
	 * @param boolean $resetPage  Do we also want to reset the current and loaded pages?
	 */
	function clearCache( $resetPage = true )
	{
		$this->_factory->clearCache();
		$this->_dataSignature = null;
		$this->_pagedIds = array();
		$this->_pageCount = 0;
		if( $resetPage ) {
			$this->_page = 0;
			$this->_loadedPages = array();
		}
	}
	
	/**
	 * Clear this pagination object of any data collected under the given factory registration hash.
	 * This method to be called from the associated factory class when it changes any data relating
	 * to the supplied reg hash.
	 * After clearing we reload the data from the factory.
	 * 
	 * @param string $regHash  The factory registration hash
	 */
	function clearRegCache( $regHash )
	{
		// Perform the cache clearing
		$this->_dataSignature = null;
		$this->_pagedIds = array();
		$this->_pageCount = 0;
		$this->_page = 0;
		$this->_loadedPages = array();
		
		// Get the search parameters from the factory
		$searchParams = $this->_factory->getSearchParams( $regHash );
		
		// Re-query the factory for the fresh data
		$this->setData( $searchParams['reqs'], $searchParams['orders'] );
	}
}
?>